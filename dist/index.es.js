import t,{useState as e,useEffect as r,useRef as n}from"react";import o from"prop-types";function i(){return(i=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(t[n]=r[n])}return t}).apply(this,arguments)}const c=(t,e)=>Math.round(Math.random()*(e-t)+t);function l(t,n){const[o,i]=e(),c=()=>{const e=t.current.offsetWidth,r=t.current.offsetHeight;n.current.width=e,n.current.height=r,i({width:e,height:r})};return r((()=>(window.onresize=c,c(),()=>{window.onresize=null})),[]),o}function s(t,e,n,o){const i=l(t,e);return r((()=>{let t,r,l,s,h;return i&&(t=e.current.getContext("2d"),t.fillStyle=o,[...Array(n)].forEach((()=>{const t=Math.PI/180*c(0,360),e=c(1,3),n=(o=c(0,i.width),s=c(0,i.height),h=Math.cos(t)*e,u=Math.sin(t)*e,{x:o,y:s,sx:o,sy:s,mx:h,my:u,alpha:.1*e,next:null});var o,s,h,u;r||(r=n),l||(l=n),l.next=n,l=n})),h=20,s=setInterval((()=>{let e=r;for(t.clearRect(-20,-20,i.width+h,i.height+h);e;)e.x<-20||e.x>i.width+h||e.y<-20||e.y>i.height+h?(e.x=e.sx,e.y=e.sy):(e.x+=e.mx,e.y+=e.my),t.globalAlpha=e.alpha,t.fillRect(e.x,e.y,2,2),e=e.next}),35)),()=>{clearInterval(s)}}),[i,n,o]),null}const h={position:"absolute",pointerEvents:"none"},u=({children:e,count:r,color:o,width:c,height:l,borderRadius:u,contentStyle:a,...d})=>{const p=n(),f=n();return s(p,f,r,o),t.createElement("div",i({ref:p},d),t.createElement("canvas",{ref:f,style:{borderRadius:u,...h}}),t.createElement("div",{style:{...c&&l?{width:c,height:l}:{},borderRadius:u,...a}},e))};u.propTypes={children:o.any,count:o.number.isRequired,width:o.oneOfType([o.string,o.number]),height:o.oneOfType([o.string,o.number]),color:o.string,borderRadius:o.string,contentStyle:o.object},u.defaultProps={children:null,color:"#000000",width:null,height:null,borderRadius:null,contentStyle:{}};const a={threshold:0,rootMargin:"0px 0px 0px 0px"};function d(t,e,n,o=a){n&&e&&r((()=>{const r=[];if(t.current&&"function"==typeof IntersectionObserver){const i=t=>e=>{n(e[0],t)};return t.current.querySelectorAll(e).forEach(((t,e)=>{const n=new IntersectionObserver(i(e),o);n.observe(t),r.push(n)})),()=>{r.forEach((t=>{t.disconnect()}))}}return()=>{}}),[t.current,o.threshold,o.rootMargin])}export{u as PixelEffectContainer,c as rand,d as useIntersection,s as usePixelEffect,l as useResizeCanvasToContainer};
